{"version":3,"sources":["webpack:///path---tutorial-steps-14-managing-favourites-with-redux-da5f9d0ab727057b26cd.js","webpack:///./.cache/json/tutorial-steps-14-managing-favourites-with-redux.json"],"names":["webpackJsonp","328","module","exports","data","markdownRemark","html","frontmatter","title","step","allMarkdownRemark","edges","node","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,eAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,gwtBAA24pBC,aAA+7DC,MAAA,iCAAAC,KAAA,KAAoDC,mBAAsBC,QAAUC,MAAQC,QAAUC,KAAA,oBAA0BP,aAAgBC,MAAA,QAAAC,KAAA,SAAgCG,MAAQC,QAAUC,KAAA,8BAAoCP,aAAgBC,MAAA,kBAAAC,KAAA,SAA0CG,MAAQC,QAAUC,KAAA,oCAA0CP,aAAgBC,MAAA,4BAAAC,KAAA,MAAiDG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,oCAAAC,KAAA,OAA0DG,MAAQC,QAAUC,KAAA,wCAA8CP,aAAgBC,MAAA,mBAAAC,KAAA,OAAyCG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,kBAAAC,KAAA,OAAwCG,MAAQC,QAAUC,KAAA,oCAA0CP,aAAgBC,MAAA,sBAAAC,KAAA,OAA4CG,MAAQC,QAAUC,KAAA,sDAA4DP,aAAgBC,MAAA,iCAAAC,KAAA,OAAuDG,MAAQC,QAAUC,KAAA,yDAA+DP,aAAgBC,MAAA,oCAAAC,KAAA,OAA0DG,MAAQC,QAAUC,KAAA,sCAA4CP,aAAgBC,MAAA,gCAAAC,KAAA,OAAsDG,MAAQC,QAAUC,KAAA,yCAA+CP,aAAgBC,MAAA,oBAAAC,KAAA,OAA0CG,MAAQC,QAAUC,KAAA,6CAAmDP,aAAgBC,MAAA,wBAAAC,KAAA,OAA8CG,MAAQC,QAAUC,KAAA,8CAAoDP,aAAgBC,MAAA,yBAAAC,KAAA,OAA+CG,MAAQC,QAAUC,KAAA,8BAAoCP,aAAgBC,MAAA,qBAAAC,KAAA,MAA0CG,MAAQC,QAAUC,KAAA,oDAA0DP,aAAgBC,MAAA,wCAAAC,KAAA,OAA8DG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,kBAAAC,KAAA,OAAwCG,MAAQC,QAAUC,KAAA,oDAA0DP,aAAgBC,MAAA,+BAAAC,KAAA,OAAqDG,MAAQC,QAAUC,KAAA,8CAAoDP,aAAgBC,MAAA,4BAAAC,KAAA,OAAkDG,MAAQC,QAAUC,KAAA,4CAAkDP,aAAgBC,MAAA,8BAAAC,KAAA,OAAoDG,MAAQC,QAAUC,KAAA,wCAA8CP,aAAgBC,MAAA,sBAAAC,KAAA,OAA4CG,MAAQC,QAAUC,KAAA,4BAAkCP,aAAgBC,MAAA,mBAAAC,KAAA,MAAwCG,MAAQC,QAAUC,KAAA,0CAAgDP,aAAgBC,MAAA,sBAAAC,KAAA,MAA2CG,MAAQC,QAAUC,KAAA,qCAA2CP,aAAgBC,MAAA,iBAAAC,KAAA,MAAsCG,MAAQC,QAAUC,KAAA,qCAA2CP,aAAgBC,MAAA,sBAAAC,KAAA,MAA2CG,MAAQC,QAAUC,KAAA,2CAAiDP,aAAgBC,MAAA,0BAAAC,KAAA,MAA+CG,MAAQC,QAAUC,KAAA,+CAAqDP,aAAgBC,MAAA,2BAAAC,KAAA,MAAgDG,MAAQC,QAAUC,KAAA,yCAA+CP,aAAgBC,MAAA,qBAAAC,KAAA,QAA2CM,aAAgBD,KAAA","file":"path---tutorial-steps-14-managing-favourites-with-redux-da5f9d0ab727057b26cd.js","sourcesContent":["webpackJsonp([1033659491245],{\n\n/***/ 328:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Now that we have Redux setup we will continue on the Redux topic by adding Redux\\nactions that will be responsible for adding and removing favourites from our\\nstate in the Redux store. This means that when we add a favourite on the map the\\nfavourites list will automatically update.</p>\\n<h2>Adding out first Action</h2>\\n<p>Let's begin by creating a directory in the application where all of our actions\\nwill be stored.</p>\\n<pre><code class=\\\"language-bash\\\">mkdir app/js/actions\\n</code></pre>\\n<p>Next we will create an <code>index.js</code> file in this directory that will be\\nresponsible for exporting all our actions from our various actions files.</p>\\n<p>Create the <code>index.js</code> file and export everything from the <code>points.js</code> file\\n(which we will create in a moment) using the <code>*</code> wildcard.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/actions/index.js\\n\\nexport * from './points';\\n</code></pre>\\n<p>Next we will create the <code>points.js</code> file that will contain our actions related\\nto points. Let's start by creating an action called <code>addFavourite</code> which will\\nsignal to our application that the user set a point on the map as a favourite,\\nallowing the application to update accordingly.</p>\\n<p>Redux actions are simply functions that return an object. The object must have a\\nkey called <code>type</code> with a unique value identifying the action. It is standard to\\nname the type in uppercase.</p>\\n<p>The action object can also contain other information. For example in this case\\nwe will store an entry called <code>index</code> in the action which will be the array\\nindex of the point that should be marked as a favourite.</p>\\n<p>It is also a common standard to put additional information in a sub-object\\ncalled <code>payload</code> to differentiate it from the <code>type</code>.</p>\\n<p>Go ahead and add the <code>points.js</code> file with the <code>addFavourite</code> action.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/actions/points.js\\n\\nexport const addFavourite = index => {\\n  return {\\n    type: 'FAVOURITE_ADDED',\\n    payload: {\\n      index: index\\n    }\\n  };\\n};\\n</code></pre>\\n<p>We are also going to need an action to tell the application that a favourite was\\nremoved. Let's add a <code>removeFavourite</code> action. It will look similar to our \\\"add\\\"\\naction as it also needs the array index of the point to update.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/actions/points.js\\n\\n  export const addFavourite = index => {\\n    return {\\n      type: 'FAVOURITE_ADDED',\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n\\n+ export const removeFavourite = index => {\\n+   return {\\n+     type: 'FAVOURITE_REMOVED',\\n+     payload: {\\n+       index: index\\n+     }\\n+   };\\n+ };\\n</code></pre>\\n<h4>Using Constants for Action Types</h4>\\n<p>As was mentioned, Redux actions types have to be unique in case they override\\neach other. As it would be possible to have actions with the same names as your\\napplication grows if you just use uppercase strings for the action type it is a\\ncommon practise to introduce a \\\"constants\\\" file that defines all shared\\nconstants for your Redux actions (as well as for other constants you need to\\nshare). Let's create a <code>constants.js</code> file in the <code>app/js/</code> directory that will\\ndefine our action types. All constants in this file should be exported.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/constants.js\\n\\nexport const FAVOURITE_ADDED = 'FAVOURITE_ADDED';\\nexport const FAVOURITE_REMOVED = 'FAVOURITE_REMOVED';\\n</code></pre>\\n<p>We now need to import these constants as the action types into our points\\nactions.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/actions/points.js\\n\\n+ import { FAVOURITE_ADDED, FAVOURITE_REMOVED } from '../constants';\\n\\n  export const addFavourite = index => {\\n    return {\\n-     type: 'FAVOURITE_ADDED',\\n+     type: FAVOURITE_ADDED,\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n\\n  export const removeFavourite = index => {\\n    return {\\n-     type: 'FAVOURITE_REMOVED',\\n+     type: FAVOURITE_REMOVED,\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n</code></pre>\\n<h2>Dispatching Actions</h2>\\n<p>When an action is \\\"dispatched\\\", Redux sends the action to all reducers that were\\npassed to the store after being registered via of <code>combineReducers</code>. This means\\nthat multiple reducers can listen to one action and update the state.</p>\\n<p>For this reason it is good to design your actions and reducers in an idiomatic\\nmanner <sup id=\\\"fnref-1\\\"><a href=\\\"#fn-1\\\" class=\\\"footnote-ref\\\">1</a></sup>. This means that you should design your actions to describe exactly\\nwhat the user is doing and allow your reducers to represent your data correctly\\ninstead of simply mapping your actions to reducers. For example an application\\nmay dispatch a <code>LOGOUT</code> action and multiple reducers will listen to this and\\nupdate the state. The \\\"account\\\" reducer could remove the logged in user ID, the\\n\\\"basket\\\" reducer would clear all items from the cart, a \\\"navigation\\\" reducer\\nwould update the links shown on the navigation bar to the user.</p>\\n<p>This is preferable than having to dispatch 3 action <code>REMOVE_LOGGED_IN_USER_ID</code>,\\n<code>CLEAR_CART</code> and <code>UPDATE_NAVIGATION_LINKS</code> when the user clicks the logout\\nbutton.</p>\\n<h4>Updating points</h4>\\n<p>Now that our points actions are defined we need to wire them up to our connected\\ncomponents. We will update the <code>Pointer</code> component so that instead of simply\\nupdating it's internal <code>state</code> with the information weather a pointer is a\\nfavourite or not it will dispatch one of our Redux actions, triggering the\\npoints reducer to update the application state.</p>\\n<p>We dispatch an action by calling the <code>dispatch</code> method provided by Redux and\\npassing the returned object from our action to it. We cannot however simply\\nimport the <code>dispatch</code> method from the Redux package and use it directly. Only\\nthe Redux store has the <code>dispatch</code> method available and in a React application\\nwe do not have direct access to the store. Instead we are given the <code>dispatch</code>\\nmethod as a prop to all connected components.</p>\\n<p>We could call <code>dispatch</code> directly from the props, for example:</p>\\n<pre><code class=\\\"language-js\\\">// Import the action to our component\\nimport { myAction } from './actions';\\n\\n// Inside of a connected component, `dispatch` is available as a prop.\\nthis.props.dispatch(myAction());\\n</code></pre>\\n<p>However instead of using <code>dispatch</code> directly via the props we can map the\\ndispatch to actions when we connect the component. In the last step we saw that\\nyou can pass a <code>mapStateToProps</code> function as the first argument to the <code>connect</code>\\nmethod. The second argument that <code>connect</code> accepts is a function called\\n<code>mapDispatchToProps</code>.</p>\\n<p>The <code>mapDispatchToProps</code> method gives us access to the <code>dispatch</code> method and\\nallows us to pass functions into our component as props that will automatically\\ndispatch our actions for us. Here is an example:</p>\\n<pre><code class=\\\"language-jsx\\\">import React, { Component } from 'react';\\nimport { connect } from 'react-redux';\\nimport { myAction } from './actions';\\n\\nclass MyComponent extends Component {\\n  render() {\\n    return &#x3C;button onClick={() => this.props.triggerAction('foobar')}>;\\n  }\\n}\\n\\nconst mapDispatchToProps = dispatch => {\\n  return {\\n    triggerAction: text => dispatch(myAction(text))\\n  };\\n};\\n\\nconst ConnectedMyComponent = connect(null, mapDispatchToProps)(MyComponent);\\n\\nexport default ConnectedMyComponent;\\n</code></pre>\\n<p>In this example we import an action called <code>myAction</code> which we imagine accepts a\\ntext string. We build a <code>mapDispatchToProps</code> function that returns a prop called\\n<code>triggerAction</code> which can take a <code>text</code> argument and will dispatch the\\n<code>myAction</code> action for us with the given text string. In the <code>connect</code> call we\\nfirst pass <code>null</code> since we don't have to map any state to props. If we did\\nthough, we would pass the <code>mapStateToProps</code> function here instead. Inside the\\ncomponent there is a <code>&#x3C;button></code> tag that when clicked calls the <code>triggerAction</code>\\nprop with a static text \\\"foobar\\\" which will cause the action to be triggered -\\nmeaning all reducers will receive the <code>myAction</code> action.</p>\\n<p>Let's try it out by applying this to our <code>Pointer</code> component.</p>\\n<p>First we will import our add and remove favourite actions.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  import React, { Component } from 'react';\\n  import PropTypes from 'prop-types';\\n  import classNames from 'classnames';\\n\\n+ import { addFavourite, removeFavourite } from '../../actions';\\n  import styles from './Pointer.css';\\n</code></pre>\\n<p>We then have to connect the <code>Pointer</code> component with Redux.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  import React, { Component } from 'react';\\n  import PropTypes from 'prop-types';\\n  import classNames from 'classnames';\\n+ import { connect } from 'react-redux';\\n\\n+ import { addFavourite, removeFavourite } from '../../actions';\\n  import styles from './Pointer.css';\\n\\n- class Pointer extends Component {\\n+ export class Pointer extends Component {\\n    ...\\n  }\\n\\n+  const ConnectedPointer = connect()(Pointer);\\n\\n-  export default Pointer;\\n+  export default ConnectedPointer;\\n</code></pre>\\n<p>We then update our <code>index.js</code> file of the <code>Pointer</code> component to manage the new\\nexports.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/index.js\\n\\n  export { default } from './Pointer';\\n+ export * from './Pointer';\\n</code></pre>\\n<p>Next we create our <code>mapDispatchToProps</code> function that creates props to add and\\nremove a favourite and pass it to <code>connect</code>.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n+ const mapDispatchToProps = dispatch => {\\n+   return {\\n+     addFavourite: index => {\\n+       dispatch(addFavourite(index));\\n+     },\\n+\\n+     removeFavourite: index => {\\n+       dispatch(removeFavourite(index));\\n+     }\\n+   };\\n+ };\\n\\n- const ConnectedPointer = connect()(Pointer);\\n+ const ConnectedPointer = connect(null, mapDispatchToProps)(Pointer);\\n</code></pre>\\n<p>Due to the new props our <code>propTypes</code> definition will have to be updated. The\\n<code>index</code> prop will be the array index we want to update; this prop does not yet\\nexist but we will be passing this to the <code>Pointer</code> from the <code>Map</code> in a moment.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  Pointer.propTypes = {\\n+   addFavourite: PropTypes.func,\\n+   removeFavourite: PropTypes.func,\\n+   index: PropTypes.number,\\n    details: PropTypes.object.isRequired,\\n    x: PropTypes.number.isRequired,\\n    y: PropTypes.number.isRequired,\\n    favourite: PropTypes.bool\\n  };\\n</code></pre>\\n<p>We now must remove the internal <code>state</code> that managed wether the pointer should\\nbe displayed as a favourite or not and replace this logic by calling our Redux\\nactions instead. Most of the changes are happening inside of the <code>favourite</code>\\nmethod that now will take the array <code>index</code> and based on wether the <code>favourite</code>\\nprop is currently true or false, call the <code>addFavourite</code> or <code>removeFavourite</code>\\nprop (which dispatched the matching action) and passes the <code>index</code> to it.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\nclass Pointer extends Component {\\n  constructor (props) {\\n    super(props);\\n\\n    this.state = {\\n-     open: false,\\n-     favourite: props.favourite\\n+     open: false\\n    };\\n\\n    this.toggle = this.toggle.bind(this);\\n    this.favourite = this.favourite.bind(this);\\n  }\\n\\n  toggle (event) {\\n    event.preventDefault();\\n\\n    if (event.target === event.currentTarget) {\\n      this.setState({ open: !this.state.open });\\n    }\\n  }\\n\\n  favourite () {\\n-   this.setState({ favourite: !this.state.favourite });\\n+   const { index, favourite, removeFavourite, addFavourite } = this.props;\\n+\\n+   if (favourite) {\\n+     removeFavourite(index);\\n+   } else {\\n+     addFavourite(index);\\n+   }\\n  }\\n\\n  render () {\\n-   const { x, y, details } = this.props;\\n+   const { x, y, details, favourite } = this.props;\\n    const { name, house, words } = details;\\n\\n    const pointerClasses = classNames(styles.pointer, {\\n-     [styles.favourite]: this.state.favourite\\n+     [styles.favourite]: favourite\\n    });\\n\\n    const detailsClasses = classNames(styles.details, {\\n      [styles.hidden]: !this.state.open\\n    });\\n\\n    return (\\n      &#x3C;div\\n        className={pointerClasses}\\n        style={{ left: x, top: y }}\\n        onClick={this.toggle}\\n      >\\n        &#x3C;div className={detailsClasses}>\\n          &#x3C;header className={styles.headline}>\\n            &#x3C;h3>{name}&#x3C;/h3>\\n            &#x3C;div className={styles.detailsControls}>\\n              &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.favourite}>\\n-               {this.state.favourite ? '–' : '+'}\\n+               {favourite ? '–' : '+'}\\n              &#x3C;/a>\\n\\n              &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.toggle}>\\n                &#x26;times;\\n              &#x3C;/a>\\n            &#x3C;/div>\\n          &#x3C;/header>\\n\\n          &#x3C;p>House: {house}&#x3C;/p>\\n          &#x3C;p>Words: {words}&#x3C;/p>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n}\\n</code></pre>\\n<p>Finally we have to update the <code>Map</code> component to pass the array <code>index</code> that our\\nRedux actions rely on to our <code>Pointer</code> component as a prop.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Map/Map.jsx\\n\\n  export const Map = ({ points }) => {\\n    return (\\n      &#x3C;div className={styles.map}>\\n-       {points.map((point, index) => &#x3C;Pointer {...point} key={index} />)}\\n+       {points.map((point, index) => (\\n+         &#x3C;Pointer {...point} index={index} key={index} />\\n+       ))}\\n      &#x3C;/div>\\n    );\\n  };\\n</code></pre>\\n<h2>Reacting to a Dispatched Action</h2>\\n<p>The final step is for our reducer to listen to the dispatched actions and\\nrespond to them by changing the application state, therefore having the effect\\nof the whole application updating.</p>\\n<p>Currently our <code>points</code> reducer does not do anything when it receives and action.\\nThe <code>switch</code> statement simply falls to the default case and returns the current\\nstate. We will now update the reducer to have additional cases inside of the\\n<code>switch</code> statement that listen for the action types we dispatch.</p>\\n<p>Since our action types are defined in the <code>constants.js</code> file, we will import\\nthese and use them as the values we look for in the <code>switch</code>.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/reducers/points.js\\n\\n+ import { FAVOURITE_ADDED, FAVOURITE_REMOVED } from '../constants';\\n\\n  const initialState = [\\n    ...\\n  ];\\n\\n  const points = (state = initialState, action) => {\\n    switch (action.type) {\\n+     case FAVOURITE_ADDED:\\n+     case FAVOURITE_REMOVED:\\n      default:\\n        return state;\\n    }\\n  };\\n\\n  export default points;\\n</code></pre>\\n<p>Now when the <code>addFavourite</code> action is dispatched the <code>FAVOURITE_ADDED</code> case will\\npick it up, as the <code>removeFavourite</code> action will map to the <code>FAVOURITE_REMOVED</code>\\ncase.</p>\\n<p>We now need to update the state being passed into the reducer based on our\\naction. We will use the <code>index</code> passed inside of the <code>payload</code> section of the\\naction to identify the item inside of the state we want to update and then\\neither set the <code>favourite</code> property of that item to either <code>true</code> or <code>false</code>,\\ndepending on wether we want to add or remove the favourite.</p>\\n<p>It is important to know that reducers never simply update the <code>state</code>, they must\\ncreate a new <code>state</code> each time the data changes or the update will not be\\napplied. This concept is called \\\"immutability\\\" and it is how Redux knows wether\\nthe state has actually changed or not.</p>\\n<blockquote>\\n<p>[A reducer] should be \\\"pure\\\", which means the reducer does not mutate its\\narguments. If the reducer updates state, it should not modify the existing\\nstate object in-place. Instead, it should generate a new object containing the\\nnecessary changes. The same approach should be used for any sub-objects within\\nstate that the reducer updates. <sup id=\\\"fnref-2\\\"><a href=\\\"#fn-2\\\" class=\\\"footnote-ref\\\">2</a></sup></p>\\n</blockquote>\\n<p>Therefore we cannot simply access the array index from the <code>state</code> argument and\\nchange the <code>favourite</code> property but instead copy the item to update, modify it,\\nthen create a new array of all of the original items including the updated one.</p>\\n<p>In order to simplify this we will add a function called <code>updateFavouriteState</code>\\nthat will allow us to share this logic between the \\\"add\\\" and \\\"remove\\\" cases.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/reducers/points.js\\n\\n+ const updateFavouriteState = (index, newValue, points) => {\\n+   const updatedPoint = points[index];\\n+   updatedPoint.favourite = newValue;\\n+\\n+   return [...points.slice(0, index), updatedPoint, ...points.slice(index + 1)];\\n+ };\\n+\\n  const points = (state = initialState, action) => {\\n+   let index;\\n+\\n    switch (action.type) {\\n     case FAVOURITE_ADDED:\\n+     index = action.payload.index;\\n+     return updateFavouriteState(index, true, state);\\n+\\n     case FAVOURITE_REMOVED:\\n+     index = action.payload.index;\\n+     return updateFavouriteState(index, false, state);\\n+\\n      default:\\n        return state;\\n    }\\n  };\\n</code></pre>\\n<p>The <code>updateFavouriteState</code> function accepts the array <code>index</code> to update, the new\\nvalue for the <code>favourite</code> property (<code>true</code> or <code>false</code>) and the <code>points</code> array,\\nwhich is the <code>state</code> passed to our reducer.</p>\\n<p>We then return a new array that has all of the points from before the index, the\\nupdated item, and finally all of the items after the index. We use the ES7 <code>...</code>\\nspread operator that \\\"spreads\\\" multiple array items into an array.</p>\\n<p>The Redux documentation contains many more of these\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html\\\">immutable update patterns</a>,\\nalso for other data types such as objects <sup id=\\\"fnref-3\\\"><a href=\\\"#fn-3\\\" class=\\\"footnote-ref\\\">3</a></sup>.</p>\\n<p>That's it! If you now look at the browser and play with the map you will see\\nadding or removing a favourite place on the map will not only still update the\\nmap marker colour but will also automatically add or remove the items from the\\nlist underneath the map because all connected components are now reacting to our\\ndispatched actions. If you are using the Redux developer tools you will see the\\nactions being dispatched every time you chang a favourite state.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-5f140.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 999px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 59.73229224762967%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB9ElEQVQoz5WSW1NSYRSG+RElyEEQOWzOKgkI7C2gm9NGDYQQzGASZIiKgZnKpkbzojDHqat+79PnbsbGLiou3lnfaT2zvvUuw4LZhkvyseL2klcVGvU9shmZzc0Y2zmZ9egqC4tW/KE1mkcnQj3anQGdkxHd3ktdg9GUbv8V/eEEg9GyhOQPoGkaqqoSjUbRStucdqs0Dwr4g0Ed6HT7kbMa4fU08dQOW9u7KLmKiBURNXFXJiPWBpPVjkeSmI4anE2P+fD2mNfDJ7ybtKjtq3h8AR247PaRU/eJRBViyR0S6TyhtRSh1RSBSPJOhoficSLxiNl5n6vzHl8vT7m+7DPq1/AFw9iWXTrQsSKRVIqiQploPMtGIncPdA9YKWf4/uUFN0LfZiN+3Ey4+jRk8LyK0+PTgbZlz73E4B+V/QaaLMIUP2+mbabjZwxO6vQ6jxkPDykVtwhGwvMBb12uV3f4fNHjsLHHXiVPLLZBPBFnV8sKM7wY5wHempJX01xf9Pk4aTJ73+Zs3KJVL1LMK8L1yHwVPhBflvwSgVCIo4Ms7ZpCfVfmabOk99a85JgPaBcuWu1OTGIeF0W1t9Eo2rBgtv6KAjYXMBBew2Jz6Ml/038DpUAYp8v7T6DD5SMmhjmZKZNQSsTFTMblojgrEJMLd/ufgNON3NjQDIcAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Img: Viewing the Redux actions from the map with the redux-dev-tools\\\"\\n        title=\\\"\\\"\\n        src=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-4206a.png\\\"\\n        srcset=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-46df6.png 250w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-e3f4d.png 500w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-4206a.png 999w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-fca25.png 1499w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-6f3cb.png 1998w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-45f7f.png 2997w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-5f140.png 3586w\\\"\\n        sizes=\\\"(max-width: 999px) 100vw, 999px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>In the next step we will give the favourites list with the ability to remove\\nfavourites via Redux.</p>\\n<hr>\\n<ul>\\n<li>\\n<p><sup id=\\\"fn-1\\\">[1]</sup>:\\n<a href=\\\"https://egghead.io/courses/building-react-applications-with-idiomatic-redux\\\">https://egghead.io/courses/building-react-applications-with-idiomatic-redux</a></p>\\n</li>\\n<li>\\n<p><sup id=\\\"fn-2\\\">[2]</sup>:\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/PrerequisiteConcepts.html\\\">https://redux.js.org/docs/recipes/reducers/PrerequisiteConcepts.html</a></p>\\n</li>\\n<li>\\n<p><sup id=\\\"fn-3\\\">[3]</sup>:\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html\\\">https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html</a></p>\\n</li>\\n</ul>\",\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/tutorial/links/\"},\"frontmatter\":{\"title\":\"Links\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/getting-started/\"},\"frontmatter\":{\"title\":\"Getting Started\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/1-setup-package/\"},\"frontmatter\":{\"title\":\"Generate the package.json\",\"step\":1}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/10-pointer-details/\"},\"frontmatter\":{\"title\":\"Showing the Details of each Point\",\"step\":10}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/11-favourite-places/\"},\"frontmatter\":{\"title\":\"Favourite Places\",\"step\":11}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/12-favourites-list/\"},\"frontmatter\":{\"title\":\"Favourites List\",\"step\":12}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/13-adding-redux/\"},\"frontmatter\":{\"title\":\"Starting with Redux\",\"step\":13}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"},\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/15-removing-favourites-from-the-list/\"},\"frontmatter\":{\"title\":\"Removing Favourites from the List\",\"step\":15}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/16-ids-for-points/\"},\"frontmatter\":{\"title\":\"Adding IDs to the Points Data\",\"step\":16}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/17-testing-with-jest/\"},\"frontmatter\":{\"title\":\"Testing with Jest\",\"step\":17}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/18-testing-redux-actions/\"},\"frontmatter\":{\"title\":\"Testing Redux Actions\",\"step\":18}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/19-testing-redux-reducers/\"},\"frontmatter\":{\"title\":\"Testing Redux Reducers\",\"step\":19}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/2-webpack/\"},\"frontmatter\":{\"title\":\"Setting up Webpack\",\"step\":2}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/20-jest-component-configuration/\"},\"frontmatter\":{\"title\":\"Preparing Component testing with Jest\",\"step\":20}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/21-testing-the-map/\"},\"frontmatter\":{\"title\":\"Testing the Map\",\"step\":21}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/22-testing-connected-components/\"},\"frontmatter\":{\"title\":\"Testing Connected Components\",\"step\":22}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/23-test-the-app-component/\"},\"frontmatter\":{\"title\":\"Testing the App Component\",\"step\":23}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/24-test-favourites-list/\"},\"frontmatter\":{\"title\":\"Testing the Favourites List\",\"step\":24}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"},\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/3-babel/\"},\"frontmatter\":{\"title\":\"Setting up Babel\",\"step\":3}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/4-eslint-and-prettier/\"},\"frontmatter\":{\"title\":\"ESLint and Prettier\",\"step\":4}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/6-adding-the-map/\"},\"frontmatter\":{\"title\":\"Adding the Map\",\"step\":6}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/5-starting-react/\"},\"frontmatter\":{\"title\":\"Starting with React\",\"step\":5}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/7-styling-with-postcss/\"},\"frontmatter\":{\"title\":\"CSS Modules and PostCSS\",\"step\":7}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/9-adding-points-to-the-map/\"},\"frontmatter\":{\"title\":\"Adding Points to the Map\",\"step\":9}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/8-webpack-dev-server/\"},\"frontmatter\":{\"title\":\"Webpack Dev Server\",\"step\":8}}}]}},\"pathContext\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---tutorial-steps-14-managing-favourites-with-redux-da5f9d0ab727057b26cd.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Now that we have Redux setup we will continue on the Redux topic by adding Redux\\nactions that will be responsible for adding and removing favourites from our\\nstate in the Redux store. This means that when we add a favourite on the map the\\nfavourites list will automatically update.</p>\\n<h2>Adding out first Action</h2>\\n<p>Let's begin by creating a directory in the application where all of our actions\\nwill be stored.</p>\\n<pre><code class=\\\"language-bash\\\">mkdir app/js/actions\\n</code></pre>\\n<p>Next we will create an <code>index.js</code> file in this directory that will be\\nresponsible for exporting all our actions from our various actions files.</p>\\n<p>Create the <code>index.js</code> file and export everything from the <code>points.js</code> file\\n(which we will create in a moment) using the <code>*</code> wildcard.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/actions/index.js\\n\\nexport * from './points';\\n</code></pre>\\n<p>Next we will create the <code>points.js</code> file that will contain our actions related\\nto points. Let's start by creating an action called <code>addFavourite</code> which will\\nsignal to our application that the user set a point on the map as a favourite,\\nallowing the application to update accordingly.</p>\\n<p>Redux actions are simply functions that return an object. The object must have a\\nkey called <code>type</code> with a unique value identifying the action. It is standard to\\nname the type in uppercase.</p>\\n<p>The action object can also contain other information. For example in this case\\nwe will store an entry called <code>index</code> in the action which will be the array\\nindex of the point that should be marked as a favourite.</p>\\n<p>It is also a common standard to put additional information in a sub-object\\ncalled <code>payload</code> to differentiate it from the <code>type</code>.</p>\\n<p>Go ahead and add the <code>points.js</code> file with the <code>addFavourite</code> action.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/actions/points.js\\n\\nexport const addFavourite = index => {\\n  return {\\n    type: 'FAVOURITE_ADDED',\\n    payload: {\\n      index: index\\n    }\\n  };\\n};\\n</code></pre>\\n<p>We are also going to need an action to tell the application that a favourite was\\nremoved. Let's add a <code>removeFavourite</code> action. It will look similar to our \\\"add\\\"\\naction as it also needs the array index of the point to update.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/actions/points.js\\n\\n  export const addFavourite = index => {\\n    return {\\n      type: 'FAVOURITE_ADDED',\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n\\n+ export const removeFavourite = index => {\\n+   return {\\n+     type: 'FAVOURITE_REMOVED',\\n+     payload: {\\n+       index: index\\n+     }\\n+   };\\n+ };\\n</code></pre>\\n<h4>Using Constants for Action Types</h4>\\n<p>As was mentioned, Redux actions types have to be unique in case they override\\neach other. As it would be possible to have actions with the same names as your\\napplication grows if you just use uppercase strings for the action type it is a\\ncommon practise to introduce a \\\"constants\\\" file that defines all shared\\nconstants for your Redux actions (as well as for other constants you need to\\nshare). Let's create a <code>constants.js</code> file in the <code>app/js/</code> directory that will\\ndefine our action types. All constants in this file should be exported.</p>\\n<pre><code class=\\\"language-js\\\">// app/js/constants.js\\n\\nexport const FAVOURITE_ADDED = 'FAVOURITE_ADDED';\\nexport const FAVOURITE_REMOVED = 'FAVOURITE_REMOVED';\\n</code></pre>\\n<p>We now need to import these constants as the action types into our points\\nactions.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/actions/points.js\\n\\n+ import { FAVOURITE_ADDED, FAVOURITE_REMOVED } from '../constants';\\n\\n  export const addFavourite = index => {\\n    return {\\n-     type: 'FAVOURITE_ADDED',\\n+     type: FAVOURITE_ADDED,\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n\\n  export const removeFavourite = index => {\\n    return {\\n-     type: 'FAVOURITE_REMOVED',\\n+     type: FAVOURITE_REMOVED,\\n      payload: {\\n        index: index\\n      }\\n    };\\n  };\\n</code></pre>\\n<h2>Dispatching Actions</h2>\\n<p>When an action is \\\"dispatched\\\", Redux sends the action to all reducers that were\\npassed to the store after being registered via of <code>combineReducers</code>. This means\\nthat multiple reducers can listen to one action and update the state.</p>\\n<p>For this reason it is good to design your actions and reducers in an idiomatic\\nmanner <sup id=\\\"fnref-1\\\"><a href=\\\"#fn-1\\\" class=\\\"footnote-ref\\\">1</a></sup>. This means that you should design your actions to describe exactly\\nwhat the user is doing and allow your reducers to represent your data correctly\\ninstead of simply mapping your actions to reducers. For example an application\\nmay dispatch a <code>LOGOUT</code> action and multiple reducers will listen to this and\\nupdate the state. The \\\"account\\\" reducer could remove the logged in user ID, the\\n\\\"basket\\\" reducer would clear all items from the cart, a \\\"navigation\\\" reducer\\nwould update the links shown on the navigation bar to the user.</p>\\n<p>This is preferable than having to dispatch 3 action <code>REMOVE_LOGGED_IN_USER_ID</code>,\\n<code>CLEAR_CART</code> and <code>UPDATE_NAVIGATION_LINKS</code> when the user clicks the logout\\nbutton.</p>\\n<h4>Updating points</h4>\\n<p>Now that our points actions are defined we need to wire them up to our connected\\ncomponents. We will update the <code>Pointer</code> component so that instead of simply\\nupdating it's internal <code>state</code> with the information weather a pointer is a\\nfavourite or not it will dispatch one of our Redux actions, triggering the\\npoints reducer to update the application state.</p>\\n<p>We dispatch an action by calling the <code>dispatch</code> method provided by Redux and\\npassing the returned object from our action to it. We cannot however simply\\nimport the <code>dispatch</code> method from the Redux package and use it directly. Only\\nthe Redux store has the <code>dispatch</code> method available and in a React application\\nwe do not have direct access to the store. Instead we are given the <code>dispatch</code>\\nmethod as a prop to all connected components.</p>\\n<p>We could call <code>dispatch</code> directly from the props, for example:</p>\\n<pre><code class=\\\"language-js\\\">// Import the action to our component\\nimport { myAction } from './actions';\\n\\n// Inside of a connected component, `dispatch` is available as a prop.\\nthis.props.dispatch(myAction());\\n</code></pre>\\n<p>However instead of using <code>dispatch</code> directly via the props we can map the\\ndispatch to actions when we connect the component. In the last step we saw that\\nyou can pass a <code>mapStateToProps</code> function as the first argument to the <code>connect</code>\\nmethod. The second argument that <code>connect</code> accepts is a function called\\n<code>mapDispatchToProps</code>.</p>\\n<p>The <code>mapDispatchToProps</code> method gives us access to the <code>dispatch</code> method and\\nallows us to pass functions into our component as props that will automatically\\ndispatch our actions for us. Here is an example:</p>\\n<pre><code class=\\\"language-jsx\\\">import React, { Component } from 'react';\\nimport { connect } from 'react-redux';\\nimport { myAction } from './actions';\\n\\nclass MyComponent extends Component {\\n  render() {\\n    return &#x3C;button onClick={() => this.props.triggerAction('foobar')}>;\\n  }\\n}\\n\\nconst mapDispatchToProps = dispatch => {\\n  return {\\n    triggerAction: text => dispatch(myAction(text))\\n  };\\n};\\n\\nconst ConnectedMyComponent = connect(null, mapDispatchToProps)(MyComponent);\\n\\nexport default ConnectedMyComponent;\\n</code></pre>\\n<p>In this example we import an action called <code>myAction</code> which we imagine accepts a\\ntext string. We build a <code>mapDispatchToProps</code> function that returns a prop called\\n<code>triggerAction</code> which can take a <code>text</code> argument and will dispatch the\\n<code>myAction</code> action for us with the given text string. In the <code>connect</code> call we\\nfirst pass <code>null</code> since we don't have to map any state to props. If we did\\nthough, we would pass the <code>mapStateToProps</code> function here instead. Inside the\\ncomponent there is a <code>&#x3C;button></code> tag that when clicked calls the <code>triggerAction</code>\\nprop with a static text \\\"foobar\\\" which will cause the action to be triggered -\\nmeaning all reducers will receive the <code>myAction</code> action.</p>\\n<p>Let's try it out by applying this to our <code>Pointer</code> component.</p>\\n<p>First we will import our add and remove favourite actions.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  import React, { Component } from 'react';\\n  import PropTypes from 'prop-types';\\n  import classNames from 'classnames';\\n\\n+ import { addFavourite, removeFavourite } from '../../actions';\\n  import styles from './Pointer.css';\\n</code></pre>\\n<p>We then have to connect the <code>Pointer</code> component with Redux.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  import React, { Component } from 'react';\\n  import PropTypes from 'prop-types';\\n  import classNames from 'classnames';\\n+ import { connect } from 'react-redux';\\n\\n+ import { addFavourite, removeFavourite } from '../../actions';\\n  import styles from './Pointer.css';\\n\\n- class Pointer extends Component {\\n+ export class Pointer extends Component {\\n    ...\\n  }\\n\\n+  const ConnectedPointer = connect()(Pointer);\\n\\n-  export default Pointer;\\n+  export default ConnectedPointer;\\n</code></pre>\\n<p>We then update our <code>index.js</code> file of the <code>Pointer</code> component to manage the new\\nexports.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/index.js\\n\\n  export { default } from './Pointer';\\n+ export * from './Pointer';\\n</code></pre>\\n<p>Next we create our <code>mapDispatchToProps</code> function that creates props to add and\\nremove a favourite and pass it to <code>connect</code>.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n+ const mapDispatchToProps = dispatch => {\\n+   return {\\n+     addFavourite: index => {\\n+       dispatch(addFavourite(index));\\n+     },\\n+\\n+     removeFavourite: index => {\\n+       dispatch(removeFavourite(index));\\n+     }\\n+   };\\n+ };\\n\\n- const ConnectedPointer = connect()(Pointer);\\n+ const ConnectedPointer = connect(null, mapDispatchToProps)(Pointer);\\n</code></pre>\\n<p>Due to the new props our <code>propTypes</code> definition will have to be updated. The\\n<code>index</code> prop will be the array index we want to update; this prop does not yet\\nexist but we will be passing this to the <code>Pointer</code> from the <code>Map</code> in a moment.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  Pointer.propTypes = {\\n+   addFavourite: PropTypes.func,\\n+   removeFavourite: PropTypes.func,\\n+   index: PropTypes.number,\\n    details: PropTypes.object.isRequired,\\n    x: PropTypes.number.isRequired,\\n    y: PropTypes.number.isRequired,\\n    favourite: PropTypes.bool\\n  };\\n</code></pre>\\n<p>We now must remove the internal <code>state</code> that managed wether the pointer should\\nbe displayed as a favourite or not and replace this logic by calling our Redux\\nactions instead. Most of the changes are happening inside of the <code>favourite</code>\\nmethod that now will take the array <code>index</code> and based on wether the <code>favourite</code>\\nprop is currently true or false, call the <code>addFavourite</code> or <code>removeFavourite</code>\\nprop (which dispatched the matching action) and passes the <code>index</code> to it.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\nclass Pointer extends Component {\\n  constructor (props) {\\n    super(props);\\n\\n    this.state = {\\n-     open: false,\\n-     favourite: props.favourite\\n+     open: false\\n    };\\n\\n    this.toggle = this.toggle.bind(this);\\n    this.favourite = this.favourite.bind(this);\\n  }\\n\\n  toggle (event) {\\n    event.preventDefault();\\n\\n    if (event.target === event.currentTarget) {\\n      this.setState({ open: !this.state.open });\\n    }\\n  }\\n\\n  favourite () {\\n-   this.setState({ favourite: !this.state.favourite });\\n+   const { index, favourite, removeFavourite, addFavourite } = this.props;\\n+\\n+   if (favourite) {\\n+     removeFavourite(index);\\n+   } else {\\n+     addFavourite(index);\\n+   }\\n  }\\n\\n  render () {\\n-   const { x, y, details } = this.props;\\n+   const { x, y, details, favourite } = this.props;\\n    const { name, house, words } = details;\\n\\n    const pointerClasses = classNames(styles.pointer, {\\n-     [styles.favourite]: this.state.favourite\\n+     [styles.favourite]: favourite\\n    });\\n\\n    const detailsClasses = classNames(styles.details, {\\n      [styles.hidden]: !this.state.open\\n    });\\n\\n    return (\\n      &#x3C;div\\n        className={pointerClasses}\\n        style={{ left: x, top: y }}\\n        onClick={this.toggle}\\n      >\\n        &#x3C;div className={detailsClasses}>\\n          &#x3C;header className={styles.headline}>\\n            &#x3C;h3>{name}&#x3C;/h3>\\n            &#x3C;div className={styles.detailsControls}>\\n              &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.favourite}>\\n-               {this.state.favourite ? '–' : '+'}\\n+               {favourite ? '–' : '+'}\\n              &#x3C;/a>\\n\\n              &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.toggle}>\\n                &#x26;times;\\n              &#x3C;/a>\\n            &#x3C;/div>\\n          &#x3C;/header>\\n\\n          &#x3C;p>House: {house}&#x3C;/p>\\n          &#x3C;p>Words: {words}&#x3C;/p>\\n        &#x3C;/div>\\n      &#x3C;/div>\\n    );\\n  }\\n}\\n</code></pre>\\n<p>Finally we have to update the <code>Map</code> component to pass the array <code>index</code> that our\\nRedux actions rely on to our <code>Pointer</code> component as a prop.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Map/Map.jsx\\n\\n  export const Map = ({ points }) => {\\n    return (\\n      &#x3C;div className={styles.map}>\\n-       {points.map((point, index) => &#x3C;Pointer {...point} key={index} />)}\\n+       {points.map((point, index) => (\\n+         &#x3C;Pointer {...point} index={index} key={index} />\\n+       ))}\\n      &#x3C;/div>\\n    );\\n  };\\n</code></pre>\\n<h2>Reacting to a Dispatched Action</h2>\\n<p>The final step is for our reducer to listen to the dispatched actions and\\nrespond to them by changing the application state, therefore having the effect\\nof the whole application updating.</p>\\n<p>Currently our <code>points</code> reducer does not do anything when it receives and action.\\nThe <code>switch</code> statement simply falls to the default case and returns the current\\nstate. We will now update the reducer to have additional cases inside of the\\n<code>switch</code> statement that listen for the action types we dispatch.</p>\\n<p>Since our action types are defined in the <code>constants.js</code> file, we will import\\nthese and use them as the values we look for in the <code>switch</code>.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/reducers/points.js\\n\\n+ import { FAVOURITE_ADDED, FAVOURITE_REMOVED } from '../constants';\\n\\n  const initialState = [\\n    ...\\n  ];\\n\\n  const points = (state = initialState, action) => {\\n    switch (action.type) {\\n+     case FAVOURITE_ADDED:\\n+     case FAVOURITE_REMOVED:\\n      default:\\n        return state;\\n    }\\n  };\\n\\n  export default points;\\n</code></pre>\\n<p>Now when the <code>addFavourite</code> action is dispatched the <code>FAVOURITE_ADDED</code> case will\\npick it up, as the <code>removeFavourite</code> action will map to the <code>FAVOURITE_REMOVED</code>\\ncase.</p>\\n<p>We now need to update the state being passed into the reducer based on our\\naction. We will use the <code>index</code> passed inside of the <code>payload</code> section of the\\naction to identify the item inside of the state we want to update and then\\neither set the <code>favourite</code> property of that item to either <code>true</code> or <code>false</code>,\\ndepending on wether we want to add or remove the favourite.</p>\\n<p>It is important to know that reducers never simply update the <code>state</code>, they must\\ncreate a new <code>state</code> each time the data changes or the update will not be\\napplied. This concept is called \\\"immutability\\\" and it is how Redux knows wether\\nthe state has actually changed or not.</p>\\n<blockquote>\\n<p>[A reducer] should be \\\"pure\\\", which means the reducer does not mutate its\\narguments. If the reducer updates state, it should not modify the existing\\nstate object in-place. Instead, it should generate a new object containing the\\nnecessary changes. The same approach should be used for any sub-objects within\\nstate that the reducer updates. <sup id=\\\"fnref-2\\\"><a href=\\\"#fn-2\\\" class=\\\"footnote-ref\\\">2</a></sup></p>\\n</blockquote>\\n<p>Therefore we cannot simply access the array index from the <code>state</code> argument and\\nchange the <code>favourite</code> property but instead copy the item to update, modify it,\\nthen create a new array of all of the original items including the updated one.</p>\\n<p>In order to simplify this we will add a function called <code>updateFavouriteState</code>\\nthat will allow us to share this logic between the \\\"add\\\" and \\\"remove\\\" cases.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/reducers/points.js\\n\\n+ const updateFavouriteState = (index, newValue, points) => {\\n+   const updatedPoint = points[index];\\n+   updatedPoint.favourite = newValue;\\n+\\n+   return [...points.slice(0, index), updatedPoint, ...points.slice(index + 1)];\\n+ };\\n+\\n  const points = (state = initialState, action) => {\\n+   let index;\\n+\\n    switch (action.type) {\\n     case FAVOURITE_ADDED:\\n+     index = action.payload.index;\\n+     return updateFavouriteState(index, true, state);\\n+\\n     case FAVOURITE_REMOVED:\\n+     index = action.payload.index;\\n+     return updateFavouriteState(index, false, state);\\n+\\n      default:\\n        return state;\\n    }\\n  };\\n</code></pre>\\n<p>The <code>updateFavouriteState</code> function accepts the array <code>index</code> to update, the new\\nvalue for the <code>favourite</code> property (<code>true</code> or <code>false</code>) and the <code>points</code> array,\\nwhich is the <code>state</code> passed to our reducer.</p>\\n<p>We then return a new array that has all of the points from before the index, the\\nupdated item, and finally all of the items after the index. We use the ES7 <code>...</code>\\nspread operator that \\\"spreads\\\" multiple array items into an array.</p>\\n<p>The Redux documentation contains many more of these\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html\\\">immutable update patterns</a>,\\nalso for other data types such as objects <sup id=\\\"fnref-3\\\"><a href=\\\"#fn-3\\\" class=\\\"footnote-ref\\\">3</a></sup>.</p>\\n<p>That's it! If you now look at the browser and play with the map you will see\\nadding or removing a favourite place on the map will not only still update the\\nmap marker colour but will also automatically add or remove the items from the\\nlist underneath the map because all connected components are now reacting to our\\ndispatched actions. If you are using the Redux developer tools you will see the\\nactions being dispatched every time you chang a favourite state.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-5f140.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 999px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 59.73229224762967%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB9ElEQVQoz5WSW1NSYRSG+RElyEEQOWzOKgkI7C2gm9NGDYQQzGASZIiKgZnKpkbzojDHqat+79PnbsbGLiou3lnfaT2zvvUuw4LZhkvyseL2klcVGvU9shmZzc0Y2zmZ9egqC4tW/KE1mkcnQj3anQGdkxHd3ktdg9GUbv8V/eEEg9GyhOQPoGkaqqoSjUbRStucdqs0Dwr4g0Ed6HT7kbMa4fU08dQOW9u7KLmKiBURNXFXJiPWBpPVjkeSmI4anE2P+fD2mNfDJ7ybtKjtq3h8AR247PaRU/eJRBViyR0S6TyhtRSh1RSBSPJOhoficSLxiNl5n6vzHl8vT7m+7DPq1/AFw9iWXTrQsSKRVIqiQploPMtGIncPdA9YKWf4/uUFN0LfZiN+3Ey4+jRk8LyK0+PTgbZlz73E4B+V/QaaLMIUP2+mbabjZwxO6vQ6jxkPDykVtwhGwvMBb12uV3f4fNHjsLHHXiVPLLZBPBFnV8sKM7wY5wHempJX01xf9Pk4aTJ73+Zs3KJVL1LMK8L1yHwVPhBflvwSgVCIo4Ms7ZpCfVfmabOk99a85JgPaBcuWu1OTGIeF0W1t9Eo2rBgtv6KAjYXMBBew2Jz6Ml/038DpUAYp8v7T6DD5SMmhjmZKZNQSsTFTMblojgrEJMLd/ufgNON3NjQDIcAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Img: Viewing the Redux actions from the map with the redux-dev-tools\\\"\\n        title=\\\"\\\"\\n        src=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-4206a.png\\\"\\n        srcset=\\\"/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-46df6.png 250w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-e3f4d.png 500w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-4206a.png 999w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-fca25.png 1499w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-6f3cb.png 1998w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-45f7f.png 2997w,\\n/learning-react-and-redux-documentation/static/map-view-redux-actions-7594e5c2c43dcb32a381e4ce9f9da6f4-5f140.png 3586w\\\"\\n        sizes=\\\"(max-width: 999px) 100vw, 999px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>In the next step we will give the favourites list with the ability to remove\\nfavourites via Redux.</p>\\n<hr>\\n<ul>\\n<li>\\n<p><sup id=\\\"fn-1\\\">[1]</sup>:\\n<a href=\\\"https://egghead.io/courses/building-react-applications-with-idiomatic-redux\\\">https://egghead.io/courses/building-react-applications-with-idiomatic-redux</a></p>\\n</li>\\n<li>\\n<p><sup id=\\\"fn-2\\\">[2]</sup>:\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/PrerequisiteConcepts.html\\\">https://redux.js.org/docs/recipes/reducers/PrerequisiteConcepts.html</a></p>\\n</li>\\n<li>\\n<p><sup id=\\\"fn-3\\\">[3]</sup>:\\n<a href=\\\"https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html\\\">https://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html</a></p>\\n</li>\\n</ul>\",\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/tutorial/links/\"},\"frontmatter\":{\"title\":\"Links\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/getting-started/\"},\"frontmatter\":{\"title\":\"Getting Started\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/1-setup-package/\"},\"frontmatter\":{\"title\":\"Generate the package.json\",\"step\":1}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/10-pointer-details/\"},\"frontmatter\":{\"title\":\"Showing the Details of each Point\",\"step\":10}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/11-favourite-places/\"},\"frontmatter\":{\"title\":\"Favourite Places\",\"step\":11}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/12-favourites-list/\"},\"frontmatter\":{\"title\":\"Favourites List\",\"step\":12}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/13-adding-redux/\"},\"frontmatter\":{\"title\":\"Starting with Redux\",\"step\":13}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"},\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/15-removing-favourites-from-the-list/\"},\"frontmatter\":{\"title\":\"Removing Favourites from the List\",\"step\":15}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/16-ids-for-points/\"},\"frontmatter\":{\"title\":\"Adding IDs to the Points Data\",\"step\":16}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/17-testing-with-jest/\"},\"frontmatter\":{\"title\":\"Testing with Jest\",\"step\":17}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/18-testing-redux-actions/\"},\"frontmatter\":{\"title\":\"Testing Redux Actions\",\"step\":18}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/19-testing-redux-reducers/\"},\"frontmatter\":{\"title\":\"Testing Redux Reducers\",\"step\":19}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/2-webpack/\"},\"frontmatter\":{\"title\":\"Setting up Webpack\",\"step\":2}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/20-jest-component-configuration/\"},\"frontmatter\":{\"title\":\"Preparing Component testing with Jest\",\"step\":20}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/21-testing-the-map/\"},\"frontmatter\":{\"title\":\"Testing the Map\",\"step\":21}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/22-testing-connected-components/\"},\"frontmatter\":{\"title\":\"Testing Connected Components\",\"step\":22}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/23-test-the-app-component/\"},\"frontmatter\":{\"title\":\"Testing the App Component\",\"step\":23}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/24-test-favourites-list/\"},\"frontmatter\":{\"title\":\"Testing the Favourites List\",\"step\":24}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"},\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/3-babel/\"},\"frontmatter\":{\"title\":\"Setting up Babel\",\"step\":3}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/4-eslint-and-prettier/\"},\"frontmatter\":{\"title\":\"ESLint and Prettier\",\"step\":4}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/6-adding-the-map/\"},\"frontmatter\":{\"title\":\"Adding the Map\",\"step\":6}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/5-starting-react/\"},\"frontmatter\":{\"title\":\"Starting with React\",\"step\":5}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/7-styling-with-postcss/\"},\"frontmatter\":{\"title\":\"CSS Modules and PostCSS\",\"step\":7}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/9-adding-points-to-the-map/\"},\"frontmatter\":{\"title\":\"Adding Points to the Map\",\"step\":9}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/8-webpack-dev-server/\"},\"frontmatter\":{\"title\":\"Webpack Dev Server\",\"step\":8}}}]}},\"pathContext\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/tutorial-steps-14-managing-favourites-with-redux.json\n// module id = 328\n// module chunks = 1033659491245"],"sourceRoot":""}