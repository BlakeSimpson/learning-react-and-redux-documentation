{"version":3,"sources":["webpack:///path---tutorial-steps-25-test-the-pointer-2bd5600ba8a5f47e44e2.js","webpack:///./.cache/json/tutorial-steps-25-test-the-pointer.json"],"names":["webpackJsonp","340","module","exports","data","markdownRemark","html","frontmatter","title","step","allMarkdownRemark","edges","node","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,u6SAAg8RC,aAA6fC,MAAA,sBAAAC,KAAA,KAAyCC,mBAAsBC,QAAUC,MAAQC,QAAUC,KAAA,oBAA0BP,aAAgBC,MAAA,QAAAC,KAAA,SAAgCG,MAAQC,QAAUC,KAAA,8BAAoCP,aAAgBC,MAAA,kBAAAC,KAAA,SAA0CG,MAAQC,QAAUC,KAAA,oCAA0CP,aAAgBC,MAAA,4BAAAC,KAAA,MAAiDG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,oCAAAC,KAAA,OAA0DG,MAAQC,QAAUC,KAAA,wCAA8CP,aAAgBC,MAAA,mBAAAC,KAAA,OAAyCG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,kBAAAC,KAAA,OAAwCG,MAAQC,QAAUC,KAAA,oCAA0CP,aAAgBC,MAAA,sBAAAC,KAAA,OAA4CG,MAAQC,QAAUC,KAAA,sDAA4DP,aAAgBC,MAAA,iCAAAC,KAAA,OAAuDG,MAAQC,QAAUC,KAAA,yDAA+DP,aAAgBC,MAAA,oCAAAC,KAAA,OAA0DG,MAAQC,QAAUC,KAAA,sCAA4CP,aAAgBC,MAAA,gCAAAC,KAAA,OAAsDG,MAAQC,QAAUC,KAAA,yCAA+CP,aAAgBC,MAAA,oBAAAC,KAAA,OAA0CG,MAAQC,QAAUC,KAAA,6CAAmDP,aAAgBC,MAAA,wBAAAC,KAAA,OAA8CG,MAAQC,QAAUC,KAAA,8CAAoDP,aAAgBC,MAAA,yBAAAC,KAAA,OAA+CG,MAAQC,QAAUC,KAAA,8BAAoCP,aAAgBC,MAAA,qBAAAC,KAAA,MAA0CG,MAAQC,QAAUC,KAAA,oDAA0DP,aAAgBC,MAAA,wCAAAC,KAAA,OAA8DG,MAAQC,QAAUC,KAAA,uCAA6CP,aAAgBC,MAAA,kBAAAC,KAAA,OAAwCG,MAAQC,QAAUC,KAAA,oDAA0DP,aAAgBC,MAAA,+BAAAC,KAAA,OAAqDG,MAAQC,QAAUC,KAAA,8CAAoDP,aAAgBC,MAAA,4BAAAC,KAAA,OAAkDG,MAAQC,QAAUC,KAAA,4CAAkDP,aAAgBC,MAAA,8BAAAC,KAAA,OAAoDG,MAAQC,QAAUC,KAAA,wCAA8CP,aAAgBC,MAAA,sBAAAC,KAAA,OAA4CG,MAAQC,QAAUC,KAAA,4BAAkCP,aAAgBC,MAAA,mBAAAC,KAAA,MAAwCG,MAAQC,QAAUC,KAAA,0CAAgDP,aAAgBC,MAAA,sBAAAC,KAAA,MAA2CG,MAAQC,QAAUC,KAAA,qCAA2CP,aAAgBC,MAAA,iBAAAC,KAAA,MAAsCG,MAAQC,QAAUC,KAAA,qCAA2CP,aAAgBC,MAAA,sBAAAC,KAAA,MAA2CG,MAAQC,QAAUC,KAAA,2CAAiDP,aAAgBC,MAAA,0BAAAC,KAAA,MAA+CG,MAAQC,QAAUC,KAAA,+CAAqDP,aAAgBC,MAAA,2BAAAC,KAAA,MAAgDG,MAAQC,QAAUC,KAAA,yCAA+CP,aAAgBC,MAAA,qBAAAC,KAAA,QAA2CM,aAAgBD,KAAA","file":"path---tutorial-steps-25-test-the-pointer-2bd5600ba8a5f47e44e2.js","sourcesContent":["webpackJsonp([198134931227272],{\n\n/***/ 340:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The final step in our testing will be to test the <code>Pointer</code> class. This is again\\nsimilar to the component testing we have been doing in the previous steps.</p>\\n<p>We will be testing the unconnected version of the component, the connected\\nversion, testing that clicking the controls dispatches the correct Redux\\nactions, and also testing that clicking the open/close control toggles the\\n<code>Pointer</code> components internal \\\"open\\\" <code>state</code>.</p>\\n<h2>Testing the Unconnected Pointer</h2>\\n<p>Add the usual imports and <code>describe</code> contexts for the spec which will we will\\nplace at <code>app/js/components/Pointer/__specs__/Pointer.spec.jsx</code>.</p>\\n<p>We will define some mock data that will be used in the unconnected snapshot test\\nwhich allows us to define <code>noop</code> functions for the prop functions that Redux\\nwould normally create for us.</p>\\n<pre><code class=\\\"language-jsx\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\nimport React from 'react';\\nimport { shallow } from 'enzyme';\\n\\nimport { Pointer } from '../';\\n\\nconst noop = () => {};\\n\\nconst pointerProps = {\\n  addFavourite: noop,\\n  removeFavourite: noop,\\n  id: 42,\\n  x: 99,\\n  y: 88,\\n  details: {\\n    name: 'Winterfell',\\n    house: 'Stark',\\n    words: 'Winter is Coming'\\n  },\\n  favourite: true\\n};\\n\\ndescribe('Pointer component', () => {\\n  it('matches the snapshot', () => {\\n    const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n    expect(wrapper).toMatchSnapshot();\\n  });\\n});\\n</code></pre>\\n<h2>Testing the Connected Pointer</h2>\\n<p>Next we will import the <code>configureStore</code> method, the <code>pointsMock</code>, and check\\nthat the connected <code>Pointer</code> matches the snapshot.</p>\\n<p>We also have to stub the <code>x</code>, <code>y</code>, and <code>details</code> props that are expected by our\\n<code>propTypes</code> with fake data because Redux does not pass these props to the\\n<code>Pointer</code> component for us but instead our <code>Map</code> component does. Remember that\\nthe <code>Pointer</code> component does not have a <code>mapStateToProps</code> function.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  import React from 'react';\\n  import { shallow } from 'enzyme';\\n+ import configureStore from 'redux-mock-store';\\n\\n+ import { pointsMock } from '../../../spec-helper';\\n- import { Pointer } from '../';\\n+ import ConnectedPointer, { Pointer } from '../';\\n\\n  const noop = () => {};\\n\\n  const pointerProps = {\\n    addFavourite: noop,\\n    removeFavourite: noop,\\n    id: 'point-42',\\n    x: 99,\\n    y: 88,\\n    details: {\\n      name: 'Winterfell',\\n      house: 'Stark',\\n      words: 'Winter is Coming'\\n    },\\n    favourite: true\\n  };\\n\\n  describe('Pointer', () => {\\n    it('matches the snapshot', () => {\\n      const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n  });\\n\\n+  describe('ConnectedApp', () => {\\n+    const mockStore = configureStore([]);\\n+    const store = mockStore({ points: pointsMock });\\n+\\n+    it('maps store state to the props', () => {\\n+      const wrapper = shallow(\\n+        &#x3C;ConnectedPointer store={store} x={1} y={2} details={{}} />\\n+      );\\n+\\n+      expect(wrapper).toMatchSnapshot();\\n+    });\\n+  });\\n</code></pre>\\n<h2>Testing the Connected Controls</h2>\\n<p>We will now test that clicking on the \\\"favourite\\\" toggle control will dispatch\\nthe <code>addFavourite</code> or <code>removeFavourite</code> actions for us depending on the state of\\nour store.</p>\\n<p>We also introduce a <code>beforeEach</code> function that will clear the mock store of any\\nactions that were dispatched in a previous test, otherwise the actions stay in\\nthe store and our expectations will not match.</p>\\n<p>The one thing we need to change in the actual <code>Pointer</code> component is the <code>&#x3C;a></code>\\ntag that we use for the \\\"favourite\\\" and \\\"open/close\\\" controls.</p>\\n<p>In order to target them in our tests we cannot simply search for \\\"a\\\" because\\nthere are two of them. Instead we will update the <code>href</code> attribute to add an\\nidentifier after the hash <code>#</code>. Update the <code>Pointer</code> component as so:</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  &#x3C;header className={styles.headline}>\\n    &#x3C;h3>{name}&#x3C;/h3>\\n    &#x3C;div className={styles.detailsControls}>\\n-     &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.favourite}>\\n+     &#x3C;a href=\\\"#favourite\\\" className={styles.control} onClick={this.favourite}>\\n        {favourite ? 'â€“' : '+'}\\n      &#x3C;/a>\\n\\n-     &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.toggle}>\\n+     &#x3C;a href=\\\"#toggle\\\" className={styles.control} onClick={this.toggle}>\\n        &#x26;times;\\n      &#x3C;/a>\\n  &#x3C;/header>\\n</code></pre>\\n<p>We can now go ahead and implement the changes to our test.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  import React from 'react';\\n- import { shallow } from 'enzyme';\\n+ import { shallow, mount } from 'enzyme';\\n  import configureStore from 'redux-mock-store';\\n\\n  import { pointsMock } from '../../../spec-helper';\\n+ import { addFavourite, removeFavourite } from '../../../actions';\\n  import ConnectedPointer, { Pointer } from '../';\\n\\n  ...\\n\\n  describe('ConnectedPointer component', () => {\\n    const mockStore = configureStore([]);\\n    const store = mockStore({ points: pointsMock });\\n\\n+   beforeEach(() => {\\n+     store.clearActions();\\n+   });\\n+\\n    it('maps store state to the props', () => {\\n      const wrapper = shallow(\\n        &#x3C;ConnectedPointer store={store} x={1} y={2} details={{}} />\\n      );\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n\\n+   describe('when the favourite button is clicked', () => {\\n+     it('calls the removeFavourite action if the pointer is a favourite', () => {\\n+       const wrapper = mount(\\n+         &#x3C;ConnectedPointer {...pointerProps} store={store} />\\n+       );\\n+       const expectedAction = [removeFavourite(42)];\\n+\\n+       wrapper.find('a[href=\\\"#favourite\\\"]').simulate('click');\\n+\\n+       expect(store.getActions()).toEqual(expectedAction);\\n+     });\\n+\\n+     it('calls the addFavourite action if the pointer is a favourite', () => {\\n+       const updatedFavouriteState = { favourite: false };\\n+       const modifiedPointerProps = Object.assign(\\n+         {},\\n+         pointerProps,\\n+         updatedFavouriteState\\n+       );\\n+\\n+       const wrapper = mount(\\n+         &#x3C;ConnectedPointer {...modifiedPointerProps} store={store} />\\n+       );\\n+       const expectedAction = [addFavourite(42)];\\n+\\n+       wrapper.find('a[href=\\\"#favourite\\\"]').simulate('click');\\n+\\n+       expect(store.getActions()).toEqual(expectedAction);\\n+     });\\n+   });\\n+ });\\n</code></pre>\\n<h2>Testing Component state Changes</h2>\\n<p>The final step will be to test that the <code>state</code> property updates when the\\nopen/close toggle control is clicked on.</p>\\n<p>Since we do not need Redux to test this, these tests will be added inside the\\nunconnected <code>Pointer</code> context.</p>\\n<p>These tests are similar to the action tests we did previously. We mount the\\ncomponent using <code>mount</code>, find the button we want to click on the rendered DOM,\\nand then simulate a click on it.</p>\\n<p>In this case though we will expect that the component <code>state</code> updates instead of\\na Redux action being dispatched.</p>\\n<p>We can mock the <code>state</code> of the component by calling <code>.state()</code> on the wrapper\\nand passing an object of the state to be set, as you see in the \\\"changes open\\nstate to true, if it is false\\\" test.</p>\\n<p>We can also get the current <code>state</code> of the component by asking for one of the\\nstate keys, for example <code>wrapper.state('open');</code>.</p>\\n<p>We use this to form our expectations in each test scenario. Add the following\\ntests to the \\\"Pointer component\\\" context.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  describe('Pointer component', () => {\\n    it('matches the snapshot', () => {\\n      const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n\\n+   describe('when the toggle button is clicked', () => {\\n+     it('changes the open state to true, if it is false', () => {\\n+       const wrapper = mount(&#x3C;Pointer {...pointerProps} />);\\n+\\n+       wrapper.find('a[href=\\\"#toggle\\\"]').simulate('click');\\n+\\n+       expect(wrapper.state('open')).toEqual(true);\\n+     });\\n+\\n+     it('changes the open state to false, if it is true', () => {\\n+       const wrapper = mount(&#x3C;Pointer {...pointerProps} />);\\n+\\n+       wrapper.setState({ open: true });\\n+       wrapper.find('a[href=\\\"#toggle\\\"]').simulate('click');\\n+\\n+       expect(wrapper.state('open')).toEqual(false);\\n+     });\\n+   });\\n  });\\n</code></pre>\\n<p>That's everything! We have now tested all of our components. If we update our\\ncomponents in a breaking way in the future the tests will fail and we will have\\nto update them to match the new state of the code, or if they are failing\\nunexpectedly we will know that a bug has been introduced to our application.</p>\\n<p>Run the tests once more with <code>yarn test</code> and see that everything including our\\nRedux actions and reducer are covered with passing specs.</p>\",\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/tutorial/links/\"},\"frontmatter\":{\"title\":\"Links\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/getting-started/\"},\"frontmatter\":{\"title\":\"Getting Started\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/1-setup-package/\"},\"frontmatter\":{\"title\":\"Generate the package.json\",\"step\":1}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/10-pointer-details/\"},\"frontmatter\":{\"title\":\"Showing the Details of each Point\",\"step\":10}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/11-favourite-places/\"},\"frontmatter\":{\"title\":\"Favourite Places\",\"step\":11}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/12-favourites-list/\"},\"frontmatter\":{\"title\":\"Favourites List\",\"step\":12}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/13-adding-redux/\"},\"frontmatter\":{\"title\":\"Starting with Redux\",\"step\":13}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"},\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/15-removing-favourites-from-the-list/\"},\"frontmatter\":{\"title\":\"Removing Favourites from the List\",\"step\":15}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/16-ids-for-points/\"},\"frontmatter\":{\"title\":\"Adding IDs to the Points Data\",\"step\":16}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/17-testing-with-jest/\"},\"frontmatter\":{\"title\":\"Testing with Jest\",\"step\":17}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/18-testing-redux-actions/\"},\"frontmatter\":{\"title\":\"Testing Redux Actions\",\"step\":18}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/19-testing-redux-reducers/\"},\"frontmatter\":{\"title\":\"Testing Redux Reducers\",\"step\":19}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/2-webpack/\"},\"frontmatter\":{\"title\":\"Setting up Webpack\",\"step\":2}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/20-jest-component-configuration/\"},\"frontmatter\":{\"title\":\"Preparing Component testing with Jest\",\"step\":20}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/21-testing-the-map/\"},\"frontmatter\":{\"title\":\"Testing the Map\",\"step\":21}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/22-testing-connected-components/\"},\"frontmatter\":{\"title\":\"Testing Connected Components\",\"step\":22}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/23-test-the-app-component/\"},\"frontmatter\":{\"title\":\"Testing the App Component\",\"step\":23}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/24-test-favourites-list/\"},\"frontmatter\":{\"title\":\"Testing the Favourites List\",\"step\":24}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"},\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/3-babel/\"},\"frontmatter\":{\"title\":\"Setting up Babel\",\"step\":3}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/4-eslint-and-prettier/\"},\"frontmatter\":{\"title\":\"ESLint and Prettier\",\"step\":4}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/6-adding-the-map/\"},\"frontmatter\":{\"title\":\"Adding the Map\",\"step\":6}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/5-starting-react/\"},\"frontmatter\":{\"title\":\"Starting with React\",\"step\":5}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/7-styling-with-postcss/\"},\"frontmatter\":{\"title\":\"CSS Modules and PostCSS\",\"step\":7}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/9-adding-points-to-the-map/\"},\"frontmatter\":{\"title\":\"Adding Points to the Map\",\"step\":9}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/8-webpack-dev-server/\"},\"frontmatter\":{\"title\":\"Webpack Dev Server\",\"step\":8}}}]}},\"pathContext\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---tutorial-steps-25-test-the-pointer-2bd5600ba8a5f47e44e2.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>The final step in our testing will be to test the <code>Pointer</code> class. This is again\\nsimilar to the component testing we have been doing in the previous steps.</p>\\n<p>We will be testing the unconnected version of the component, the connected\\nversion, testing that clicking the controls dispatches the correct Redux\\nactions, and also testing that clicking the open/close control toggles the\\n<code>Pointer</code> components internal \\\"open\\\" <code>state</code>.</p>\\n<h2>Testing the Unconnected Pointer</h2>\\n<p>Add the usual imports and <code>describe</code> contexts for the spec which will we will\\nplace at <code>app/js/components/Pointer/__specs__/Pointer.spec.jsx</code>.</p>\\n<p>We will define some mock data that will be used in the unconnected snapshot test\\nwhich allows us to define <code>noop</code> functions for the prop functions that Redux\\nwould normally create for us.</p>\\n<pre><code class=\\\"language-jsx\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\nimport React from 'react';\\nimport { shallow } from 'enzyme';\\n\\nimport { Pointer } from '../';\\n\\nconst noop = () => {};\\n\\nconst pointerProps = {\\n  addFavourite: noop,\\n  removeFavourite: noop,\\n  id: 42,\\n  x: 99,\\n  y: 88,\\n  details: {\\n    name: 'Winterfell',\\n    house: 'Stark',\\n    words: 'Winter is Coming'\\n  },\\n  favourite: true\\n};\\n\\ndescribe('Pointer component', () => {\\n  it('matches the snapshot', () => {\\n    const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n    expect(wrapper).toMatchSnapshot();\\n  });\\n});\\n</code></pre>\\n<h2>Testing the Connected Pointer</h2>\\n<p>Next we will import the <code>configureStore</code> method, the <code>pointsMock</code>, and check\\nthat the connected <code>Pointer</code> matches the snapshot.</p>\\n<p>We also have to stub the <code>x</code>, <code>y</code>, and <code>details</code> props that are expected by our\\n<code>propTypes</code> with fake data because Redux does not pass these props to the\\n<code>Pointer</code> component for us but instead our <code>Map</code> component does. Remember that\\nthe <code>Pointer</code> component does not have a <code>mapStateToProps</code> function.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  import React from 'react';\\n  import { shallow } from 'enzyme';\\n+ import configureStore from 'redux-mock-store';\\n\\n+ import { pointsMock } from '../../../spec-helper';\\n- import { Pointer } from '../';\\n+ import ConnectedPointer, { Pointer } from '../';\\n\\n  const noop = () => {};\\n\\n  const pointerProps = {\\n    addFavourite: noop,\\n    removeFavourite: noop,\\n    id: 'point-42',\\n    x: 99,\\n    y: 88,\\n    details: {\\n      name: 'Winterfell',\\n      house: 'Stark',\\n      words: 'Winter is Coming'\\n    },\\n    favourite: true\\n  };\\n\\n  describe('Pointer', () => {\\n    it('matches the snapshot', () => {\\n      const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n  });\\n\\n+  describe('ConnectedApp', () => {\\n+    const mockStore = configureStore([]);\\n+    const store = mockStore({ points: pointsMock });\\n+\\n+    it('maps store state to the props', () => {\\n+      const wrapper = shallow(\\n+        &#x3C;ConnectedPointer store={store} x={1} y={2} details={{}} />\\n+      );\\n+\\n+      expect(wrapper).toMatchSnapshot();\\n+    });\\n+  });\\n</code></pre>\\n<h2>Testing the Connected Controls</h2>\\n<p>We will now test that clicking on the \\\"favourite\\\" toggle control will dispatch\\nthe <code>addFavourite</code> or <code>removeFavourite</code> actions for us depending on the state of\\nour store.</p>\\n<p>We also introduce a <code>beforeEach</code> function that will clear the mock store of any\\nactions that were dispatched in a previous test, otherwise the actions stay in\\nthe store and our expectations will not match.</p>\\n<p>The one thing we need to change in the actual <code>Pointer</code> component is the <code>&#x3C;a></code>\\ntag that we use for the \\\"favourite\\\" and \\\"open/close\\\" controls.</p>\\n<p>In order to target them in our tests we cannot simply search for \\\"a\\\" because\\nthere are two of them. Instead we will update the <code>href</code> attribute to add an\\nidentifier after the hash <code>#</code>. Update the <code>Pointer</code> component as so:</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/Pointer.jsx\\n\\n  &#x3C;header className={styles.headline}>\\n    &#x3C;h3>{name}&#x3C;/h3>\\n    &#x3C;div className={styles.detailsControls}>\\n-     &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.favourite}>\\n+     &#x3C;a href=\\\"#favourite\\\" className={styles.control} onClick={this.favourite}>\\n        {favourite ? 'â€“' : '+'}\\n      &#x3C;/a>\\n\\n-     &#x3C;a href=\\\"#\\\" className={styles.control} onClick={this.toggle}>\\n+     &#x3C;a href=\\\"#toggle\\\" className={styles.control} onClick={this.toggle}>\\n        &#x26;times;\\n      &#x3C;/a>\\n  &#x3C;/header>\\n</code></pre>\\n<p>We can now go ahead and implement the changes to our test.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  import React from 'react';\\n- import { shallow } from 'enzyme';\\n+ import { shallow, mount } from 'enzyme';\\n  import configureStore from 'redux-mock-store';\\n\\n  import { pointsMock } from '../../../spec-helper';\\n+ import { addFavourite, removeFavourite } from '../../../actions';\\n  import ConnectedPointer, { Pointer } from '../';\\n\\n  ...\\n\\n  describe('ConnectedPointer component', () => {\\n    const mockStore = configureStore([]);\\n    const store = mockStore({ points: pointsMock });\\n\\n+   beforeEach(() => {\\n+     store.clearActions();\\n+   });\\n+\\n    it('maps store state to the props', () => {\\n      const wrapper = shallow(\\n        &#x3C;ConnectedPointer store={store} x={1} y={2} details={{}} />\\n      );\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n\\n+   describe('when the favourite button is clicked', () => {\\n+     it('calls the removeFavourite action if the pointer is a favourite', () => {\\n+       const wrapper = mount(\\n+         &#x3C;ConnectedPointer {...pointerProps} store={store} />\\n+       );\\n+       const expectedAction = [removeFavourite(42)];\\n+\\n+       wrapper.find('a[href=\\\"#favourite\\\"]').simulate('click');\\n+\\n+       expect(store.getActions()).toEqual(expectedAction);\\n+     });\\n+\\n+     it('calls the addFavourite action if the pointer is a favourite', () => {\\n+       const updatedFavouriteState = { favourite: false };\\n+       const modifiedPointerProps = Object.assign(\\n+         {},\\n+         pointerProps,\\n+         updatedFavouriteState\\n+       );\\n+\\n+       const wrapper = mount(\\n+         &#x3C;ConnectedPointer {...modifiedPointerProps} store={store} />\\n+       );\\n+       const expectedAction = [addFavourite(42)];\\n+\\n+       wrapper.find('a[href=\\\"#favourite\\\"]').simulate('click');\\n+\\n+       expect(store.getActions()).toEqual(expectedAction);\\n+     });\\n+   });\\n+ });\\n</code></pre>\\n<h2>Testing Component state Changes</h2>\\n<p>The final step will be to test that the <code>state</code> property updates when the\\nopen/close toggle control is clicked on.</p>\\n<p>Since we do not need Redux to test this, these tests will be added inside the\\nunconnected <code>Pointer</code> context.</p>\\n<p>These tests are similar to the action tests we did previously. We mount the\\ncomponent using <code>mount</code>, find the button we want to click on the rendered DOM,\\nand then simulate a click on it.</p>\\n<p>In this case though we will expect that the component <code>state</code> updates instead of\\na Redux action being dispatched.</p>\\n<p>We can mock the <code>state</code> of the component by calling <code>.state()</code> on the wrapper\\nand passing an object of the state to be set, as you see in the \\\"changes open\\nstate to true, if it is false\\\" test.</p>\\n<p>We can also get the current <code>state</code> of the component by asking for one of the\\nstate keys, for example <code>wrapper.state('open');</code>.</p>\\n<p>We use this to form our expectations in each test scenario. Add the following\\ntests to the \\\"Pointer component\\\" context.</p>\\n<pre><code class=\\\"language-diff\\\">// app/js/components/Pointer/__specs__/Pointer.spec.jsx\\n\\n  describe('Pointer component', () => {\\n    it('matches the snapshot', () => {\\n      const wrapper = shallow(&#x3C;Pointer {...pointerProps} />);\\n\\n      expect(wrapper).toMatchSnapshot();\\n    });\\n\\n+   describe('when the toggle button is clicked', () => {\\n+     it('changes the open state to true, if it is false', () => {\\n+       const wrapper = mount(&#x3C;Pointer {...pointerProps} />);\\n+\\n+       wrapper.find('a[href=\\\"#toggle\\\"]').simulate('click');\\n+\\n+       expect(wrapper.state('open')).toEqual(true);\\n+     });\\n+\\n+     it('changes the open state to false, if it is true', () => {\\n+       const wrapper = mount(&#x3C;Pointer {...pointerProps} />);\\n+\\n+       wrapper.setState({ open: true });\\n+       wrapper.find('a[href=\\\"#toggle\\\"]').simulate('click');\\n+\\n+       expect(wrapper.state('open')).toEqual(false);\\n+     });\\n+   });\\n  });\\n</code></pre>\\n<p>That's everything! We have now tested all of our components. If we update our\\ncomponents in a breaking way in the future the tests will fail and we will have\\nto update them to match the new state of the code, or if they are failing\\nunexpectedly we will know that a bug has been introduced to our application.</p>\\n<p>Run the tests once more with <code>yarn test</code> and see that everything including our\\nRedux actions and reducer are covered with passing specs.</p>\",\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"fields\":{\"slug\":\"/tutorial/links/\"},\"frontmatter\":{\"title\":\"Links\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/getting-started/\"},\"frontmatter\":{\"title\":\"Getting Started\",\"step\":null}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/1-setup-package/\"},\"frontmatter\":{\"title\":\"Generate the package.json\",\"step\":1}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/10-pointer-details/\"},\"frontmatter\":{\"title\":\"Showing the Details of each Point\",\"step\":10}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/11-favourite-places/\"},\"frontmatter\":{\"title\":\"Favourite Places\",\"step\":11}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/12-favourites-list/\"},\"frontmatter\":{\"title\":\"Favourites List\",\"step\":12}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/13-adding-redux/\"},\"frontmatter\":{\"title\":\"Starting with Redux\",\"step\":13}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/14-managing-favourites-with-redux/\"},\"frontmatter\":{\"title\":\"Managing Favourites with Redux\",\"step\":14}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/15-removing-favourites-from-the-list/\"},\"frontmatter\":{\"title\":\"Removing Favourites from the List\",\"step\":15}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/16-ids-for-points/\"},\"frontmatter\":{\"title\":\"Adding IDs to the Points Data\",\"step\":16}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/17-testing-with-jest/\"},\"frontmatter\":{\"title\":\"Testing with Jest\",\"step\":17}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/18-testing-redux-actions/\"},\"frontmatter\":{\"title\":\"Testing Redux Actions\",\"step\":18}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/19-testing-redux-reducers/\"},\"frontmatter\":{\"title\":\"Testing Redux Reducers\",\"step\":19}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/2-webpack/\"},\"frontmatter\":{\"title\":\"Setting up Webpack\",\"step\":2}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/20-jest-component-configuration/\"},\"frontmatter\":{\"title\":\"Preparing Component testing with Jest\",\"step\":20}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/21-testing-the-map/\"},\"frontmatter\":{\"title\":\"Testing the Map\",\"step\":21}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/22-testing-connected-components/\"},\"frontmatter\":{\"title\":\"Testing Connected Components\",\"step\":22}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/23-test-the-app-component/\"},\"frontmatter\":{\"title\":\"Testing the App Component\",\"step\":23}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/24-test-favourites-list/\"},\"frontmatter\":{\"title\":\"Testing the Favourites List\",\"step\":24}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"},\"frontmatter\":{\"title\":\"Testing the Pointer\",\"step\":25}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/3-babel/\"},\"frontmatter\":{\"title\":\"Setting up Babel\",\"step\":3}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/4-eslint-and-prettier/\"},\"frontmatter\":{\"title\":\"ESLint and Prettier\",\"step\":4}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/6-adding-the-map/\"},\"frontmatter\":{\"title\":\"Adding the Map\",\"step\":6}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/5-starting-react/\"},\"frontmatter\":{\"title\":\"Starting with React\",\"step\":5}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/7-styling-with-postcss/\"},\"frontmatter\":{\"title\":\"CSS Modules and PostCSS\",\"step\":7}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/9-adding-points-to-the-map/\"},\"frontmatter\":{\"title\":\"Adding Points to the Map\",\"step\":9}}},{\"node\":{\"fields\":{\"slug\":\"/tutorial/steps/8-webpack-dev-server/\"},\"frontmatter\":{\"title\":\"Webpack Dev Server\",\"step\":8}}}]}},\"pathContext\":{\"slug\":\"/tutorial/steps/25-test-the-pointer/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/tutorial-steps-25-test-the-pointer.json\n// module id = 340\n// module chunks = 198134931227272"],"sourceRoot":""}